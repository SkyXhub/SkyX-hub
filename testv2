--[[  
    SkyX Language Compiler
    
    This script converts .sky files (our custom language) to regular Lua
    for use in Roblox exploits.
    
    Usage:
    1. Local: require("SkyX_Compiler"):compile(skyCodeString)
    2. In-game: loadstring(game:HttpGet('https://raw.githubusercontent.com/SkyXHub/SkyXLanguage/main/SkyX_Compiler.lua'))()(skyCodeString)
]]--

local SkyXCompiler = {}
SkyXCompiler.__index = SkyXCompiler

-- Create a new compiler instance
function SkyXCompiler.new()
    local self = setmetatable({}, SkyXCompiler)
    self.debug = false
    self.blockHandlers = {
        ["setup"] = self.processSetupBlock,
        ["ui"] = self.processUIBlock,
        ["function"] = self.processFunctionBlock,
        ["esp"] = self.processESPBlock,
        ["aimbot"] = self.processAimbotBlock
    }
    return self
end

-- Main compile function that converts sky code to lua
function SkyXCompiler:compile(skyCode)
    -- Parse the sky code into blocks
    local blocks = self:parseBlocks(skyCode)
    
    -- Generate the output code
    local output = {}
    table.insert(output, "-- Generated by SkyX Language Compiler")
    table.insert(output, "local SkyX = {}")
    
    -- Add the standard library
    table.insert(output, self:generateStandardLibrary())
    
    -- Process each block
    for _, block in ipairs(blocks) do
        local handler = self.blockHandlers[block.type]
        if handler then
            table.insert(output, handler(self, block))
        else
            table.insert(output, "-- Unknown block type: " .. block.type)
        end
    end
    
    -- Add initialization code
    table.insert(output, "-- Initialize SkyX")
    table.insert(output, "SkyX:init()")
    table.insert(output, "return SkyX")
    
    return table.concat(output, "\n")
end

-- Parse sky code into blocks
function SkyXCompiler:parseBlocks(skyCode)
    local blocks = {}
    local lines = {}
    
    -- Split the code into lines
    for line in skyCode:gmatch("[^\n]+") do
        table.insert(lines, line)
    end
    
    local i = 1
    while i <= #lines do
        local line = lines[i]:match("^%s*(.-)%s*$") -- Trim whitespace
        
        -- Skip comments
        if line:sub(1, 2) == "//" or line == "" then
            i = i + 1
        -- Match block start
        elseif line:match("^@(%w+)%s*{$") then
            local blockType = line:match("^@(%w+)%s*{$")
            local blockContent = ""
            local j = i + 1
            
            -- Collect block content until closing brace
            while j <= #lines and not lines[j]:match("^%s*}%s*$") do
                blockContent = blockContent .. lines[j] .. "\n"
                j = j + 1
            end
            
            table.insert(blocks, {
                type = blockType,
                name = "",
                content = blockContent
            })
            
            i = j + 1
        -- Match named block start
        elseif line:match("^@(%w+)%s+([%w_]+)%s*{$") then
            local blockType, blockName = line:match("^@(%w+)%s+([%w_]+)%s*{$")
            local blockContent = ""
            local j = i + 1
            
            -- Collect block content until closing brace
            while j <= #lines and not lines[j]:match("^%s*}%s*$") do
                blockContent = blockContent .. lines[j] .. "\n"
                j = j + 1
            end
            
            table.insert(blocks, {
                type = blockType,
                name = blockName,
                content = blockContent
            })
            
            i = j + 1
        else
            i = i + 1
        end
    end
    
    return blocks
end

-- Generate standard library
function SkyXCompiler:generateStandardLibrary()
    local lib = [[
-- SkyX Standard Library
function SkyX:log(message)
    print("[SkyX] " .. message)
end

function SkyX:warn(message)
    warn("[SkyX Warning] " .. message)
end

function SkyX:error(message)
    error("[SkyX Error] " .. message)
end

function SkyX:init()
    self:log("Initializing SkyX Script...")
    
    -- Setup UI library
    local success, err = pcall(function()
        self.Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Orion/main/source'))()
        self.Window = self.Library:MakeWindow({
            Name = self.uiTitle or "SkyX Script",
            HidePremium = true,
            SaveConfig = true,
            ConfigFolder = "SkyXScripts"
        })
    end)
    
    if not success then
        self:warn("Failed to load UI library: " .. tostring(err))
    end
    
    -- Execute all init functions
    if self.initFunctions then
        for _, func in ipairs(self.initFunctions) do
            func()
        end
    end
    
    self:log("SkyX Script initialized")
end
]]
    return lib
end

-- Process setup block
function SkyXCompiler:processSetupBlock(block)
    local output = {}
    table.insert(output, "-- Setup configuration")
    
    -- Parse properties
    for line in block.content:gmatch("([^\n]+)") do
        local trimmedLine = line:match("^%s*(.-)%s*$") -- Trim whitespace
        if trimmedLine ~= "" and trimmedLine:sub(1, 2) ~= "//" then
            local key, value = trimmedLine:match("([%w_]+):%s*(.+)")
            if key and value then
                if key == "game" then
                    table.insert(output, "SkyX.targetGame = " .. value)
                elseif key == "ui" then
                    -- Parse UI settings
                    local title = value:match("title:%s*\"([^\"]+)\"")
                    local theme = value:match("theme:%s*\"([^\"]+)\"")
                    
                    if title then
                        table.insert(output, "SkyX.uiTitle = \"" .. title .. "\"")
                    end
                    
                    if theme then
                        table.insert(output, "SkyX.uiTheme = \"" .. theme .. "\"")
                    end
                end
            end
        end
    end
    
    return table.concat(output, "\n")
end

-- Process UI block
function SkyXCompiler:processUIBlock(block)
    if not block.name or block.name == "" then
        return "-- Error: UI block must have a name"
    end
    
    local output = {}
    table.insert(output, "-- UI tab: " .. block.name)
    table.insert(output, "SkyX." .. block.name .. "Tab = SkyX.Window:MakeTab({")
    table.insert(output, "    Name = \"" .. block.name .. "\",")
    table.insert(output, "    Icon = \"rbxassetid://4483345998\",")
    table.insert(output, "    PremiumOnly = false")
    table.insert(output, "})")
    
    -- Process UI elements
    for line in block.content:gmatch("([^\n]+)") do
        local trimmedLine = line:match("^%s*(.-)%s*$") -- Trim whitespace
        if trimmedLine ~= "" and trimmedLine:sub(1, 2) ~= "//" then
            -- Match UI element patterns
            local elementType, params = trimmedLine:match("^([%w_]+)%((.+)%)$")
            
            if elementType == "button" then
                -- button("Name", callback)
                local name, callback = params:match('"([^"]+)"%s*,%s*([%w_]+)')
                if name and callback then
                    table.insert(output, "SkyX." .. block.name .. "Tab:AddButton({")
                    table.insert(output, "    Name = \"" .. name .. "\",")
                    table.insert(output, "    Callback = function()")
                    table.insert(output, "        " .. callback .. "()")
                    table.insert(output, "    end")
                    table.insert(output, "})")
                end
            elseif elementType == "toggle" then
                -- toggle("Name", default, callback)
                local name, default, callback = params:match('"([^"]+)"%s*,%s*([%w_]+)%s*,%s*([%w_]+)')
                if name and callback then
                    table.insert(output, "SkyX." .. block.name .. "Tab:AddToggle({")
                    table.insert(output, "    Name = \"" .. name .. "\",")
                    table.insert(output, "    Default = " .. (default or "false") .. ",")
                    table.insert(output, "    Callback = function(Value)")
                    table.insert(output, "        " .. callback .. "(Value)")
                    table.insert(output, "    end")
                    table.insert(output, "})")
                end
            elseif elementType == "slider" then
                -- slider("Name", min, max, default, callback)
                local name, min, max, default, callback = params:match('"([^"]+)"%s*,%s*([%d%.]+)%s*,%s*([%d%.]+)%s*,%s*([%d%.]+)%s*,%s*([%w_]+)')
                if name and min and max and default and callback then
                    table.insert(output, "SkyX." .. block.name .. "Tab:AddSlider({")
                    table.insert(output, "    Name = \"" .. name .. "\",")
                    table.insert(output, "    Min = " .. min .. ",")
                    table.insert(output, "    Max = " .. max .. ",")
                    table.insert(output, "    Default = " .. default .. ",")
                    table.insert(output, "    Color = Color3.fromRGB(255, 255, 255),")
                    table.insert(output, "    Increment = 0.1,")
                    table.insert(output, "    Callback = function(Value)")
                    table.insert(output, "        " .. callback .. "(Value)")
                    table.insert(output, "    end")
                    table.insert(output, "})")
                end
            end
        end
    end
    
    return table.concat(output, "\n")
end

-- Process function block
function SkyXCompiler:processFunctionBlock(block)
    if not block.name or block.name == "" then
        return "-- Error: Function block must have a name"
    end
    
    local output = {}
    table.insert(output, "-- Function: " .. block.name)
    table.insert(output, "function " .. block.name .. "(Value)")
    
    -- Include the function body as-is
    for line in block.content:gmatch("([^\n]+)") do
        if line:match("^%s*(.-)%s*$") ~= "" then
            table.insert(output, "    " .. line)
        end
    end
    
    table.insert(output, "end")
    
    return table.concat(output, "\n")
end

-- Process ESP block
function SkyXCompiler:processESPBlock(block)
    local output = {}
    table.insert(output, "-- ESP configuration")
    table.insert(output, "SkyX.ESP = {")
    table.insert(output, "    Enabled = false,")
    table.insert(output, "    TeamCheck = false,")
    table.insert(output, "    BoxesEnabled = true,")
    table.insert(output, "    NamesEnabled = true,")
    table.insert(output, "    DistanceEnabled = true,")
    table.insert(output, "    BoxColor = Color3.fromRGB(255, 0, 0),")
    table.insert(output, "    TextColor = Color3.fromRGB(255, 255, 255),")
    table.insert(output, "    MaxDistance = 1000")
    table.insert(output, "}")
    
    -- Parse ESP settings
    for line in block.content:gmatch("([^\n]+)") do
        local trimmedLine = line:match("^%s*(.-)%s*$") -- Trim whitespace
        if trimmedLine ~= "" and trimmedLine:sub(1, 2) ~= "//" then
            local key, value = trimmedLine:match("([%w_]+):%s*(.+)")
            if key and value then
                if key == "enabled" then
                    table.insert(output, "SkyX.ESP.Enabled = " .. value)
                elseif key == "teamCheck" then
                    table.insert(output, "SkyX.ESP.TeamCheck = " .. value)
                elseif key == "boxes" then
                    table.insert(output, "SkyX.ESP.BoxesEnabled = " .. value)
                elseif key == "names" then
                    table.insert(output, "SkyX.ESP.NamesEnabled = " .. value)
                elseif key == "distance" then
                    table.insert(output, "SkyX.ESP.DistanceEnabled = " .. value)
                elseif key == "color" then
                    table.insert(output, "SkyX.ESP.BoxColor = " .. value)
                elseif key == "textColor" then
                    table.insert(output, "SkyX.ESP.TextColor = " .. value)
                elseif key == "maxDistance" then
                    table.insert(output, "SkyX.ESP.MaxDistance = " .. value)
                end
            end
        end
    end
    
    -- Add ESP implementation
    local espImpl = [[
-- Initialize ESP when SkyX starts
SkyX.initFunctions = SkyX.initFunctions or {}
table.insert(SkyX.initFunctions, function()
    -- Only initialize once
    if SkyX._espInitialized then return end
    SkyX._espInitialized = true
    
    -- Check for Drawing library
    if not Drawing then
        SkyX:warn("Drawing library not available, ESP will not work")
        return
    end
    
    -- Create ESP objects for all players
    SkyX.ESP.Objects = {}
    
    function SkyX.ESP:CreateObject(player)
        if player == game.Players.LocalPlayer then return end
        if self.Objects[player] then return end
        
        local box = Drawing.new("Square")
        box.Visible = false
        box.Color = self.BoxColor
        box.Thickness = 1
        box.Transparency = 0.7
        box.Filled = false
        
        local name = Drawing.new("Text")
        name.Visible = false
        name.Color = self.TextColor
        name.Size = 14
        name.Center = true
        name.Outline = true
        
        local distance = Drawing.new("Text")
        distance.Visible = false
        distance.Color = self.TextColor
        distance.Size = 12
        distance.Center = true
        distance.Outline = true
        
        self.Objects[player] = {
            Box = box,
            Name = name,
            Distance = distance
        }
    end
    
    function SkyX.ESP:RemoveObject(player)
        if not self.Objects[player] then return end
        
        for _, object in pairs(self.Objects[player]) do
            object.Visible = false
            object:Remove()
        end
        
        self.Objects[player] = nil
    end
    
    function SkyX.ESP:UpdateObjects()
        local camera = workspace.CurrentCamera
        local localPlayer = game.Players.LocalPlayer
        
        for player, objects in pairs(self.Objects) do
            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character.HumanoidRootPart
                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                
                if not humanoid or humanoid.Health <= 0 then
                    for _, object in pairs(objects) do
                        object.Visible = false
                    end
                    continue
                end
                
                -- Check team
                if self.TeamCheck and player.Team == localPlayer.Team then
                    for _, object in pairs(objects) do
                        object.Visible = false
                    end
                    continue
                end
                
                -- Check distance
                local distance = (hrp.Position - camera.CFrame.Position).Magnitude
                if distance > self.MaxDistance then
                    for _, object in pairs(objects) do
                        object.Visible = false
                    end
                    continue
                end
                
                -- Get screen position
                local vector, onScreen = camera:WorldToViewportPoint(hrp.Position)
                if not onScreen then
                    for _, object in pairs(objects) do
                        object.Visible = false
                    end
                    continue
                end
                
                -- Update objects based on settings
                if self.Enabled then
                    -- Calculate box size based on distance
                    local size = math.clamp(1000 / distance, 10, 30)
                    local boxSize = Vector2.new(size, size * 1.5)
                    
                    -- Update box
                    if self.BoxesEnabled then
                        objects.Box.Size = boxSize
                        objects.Box.Position = Vector2.new(vector.X - boxSize.X / 2, vector.Y - boxSize.Y / 2)
                        objects.Box.Visible = true
                        objects.Box.Color = self.BoxColor
                    else
                        objects.Box.Visible = false
                    end
                    
                    -- Update name
                    if self.NamesEnabled then
                        objects.Name.Position = Vector2.new(vector.X, vector.Y - boxSize.Y / 2 - 15)
                        objects.Name.Text = player.Name
                        objects.Name.Visible = true
                        objects.Name.Color = self.TextColor
                    else
                        objects.Name.Visible = false
                    end
                    
                    -- Update distance
                    if self.DistanceEnabled then
                        objects.Distance.Position = Vector2.new(vector.X, vector.Y + boxSize.Y / 2 + 5)
                        objects.Distance.Text = math.floor(distance) .. " studs"
                        objects.Distance.Visible = true
                        objects.Distance.Color = self.TextColor
                    else
                        objects.Distance.Visible = false
                    end
                else
                    -- Hide everything if ESP is disabled
                    for _, object in pairs(objects) do
                        object.Visible = false
                    end
                end
            else
                -- Hide everything if character is invalid
                for _, object in pairs(objects) do
                    object.Visible = false
                end
            end
        end
    end
    
    -- Initialize objects for current players
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            SkyX.ESP:CreateObject(player)
        end
    end
    
    -- Connect events
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            SkyX.ESP:CreateObject(player)
        end
    end)
    
    game.Players.PlayerRemoving:Connect(function(player)
        SkyX.ESP:RemoveObject(player)
    end)
    
    -- Update loop
    game:GetService("RunService").RenderStepped:Connect(function()
        SkyX.ESP:UpdateObjects()
    end)
    
    SkyX:log("ESP system initialized")
end)
]]
    
    table.insert(output, espImpl)
    
    return table.concat(output, "\n")
end

-- Process aimbot block
function SkyXCompiler:processAimbotBlock(block)
    local output = {}
    table.insert(output, "-- Aimbot configuration")
    table.insert(output, "SkyX.Aimbot = {")
    table.insert(output, "    Enabled = false,")
    table.insert(output, "    TeamCheck = true,")
    table.insert(output, "    TargetPart = \"Head\",")
    table.insert(output, "    FOV = 250,")
    table.insert(output, "    ShowFOV = true,")
    table.insert(output, "    FOVColor = Color3.fromRGB(255, 255, 255),")
    table.insert(output, "    Smoothness = 0.5,")
    table.insert(output, "    TriggerKey = Enum.KeyCode.E")
    table.insert(output, "}")
    
    -- Parse aimbot settings
    for line in block.content:gmatch("([^\n]+)") do
        local trimmedLine = line:match("^%s*(.-)%s*$") -- Trim whitespace
        if trimmedLine ~= "" and trimmedLine:sub(1, 2) ~= "//" then
            local key, value = trimmedLine:match("([%w_]+):%s*(.+)")
            if key and value then
                if key == "enabled" then
                    table.insert(output, "SkyX.Aimbot.Enabled = " .. value)
                elseif key == "teamCheck" then
                    table.insert(output, "SkyX.Aimbot.TeamCheck = " .. value)
                elseif key == "target" then
                    table.insert(output, "SkyX.Aimbot.TargetPart = " .. value)
                elseif key == "fov" then
                    table.insert(output, "SkyX.Aimbot.FOV = " .. value)
                elseif key == "showFov" then
                    table.insert(output, "SkyX.Aimbot.ShowFOV = " .. value)
                elseif key == "fovColor" then
                    table.insert(output, "SkyX.Aimbot.FOVColor = " .. value)
                elseif key == "smoothness" then
                    table.insert(output, "SkyX.Aimbot.Smoothness = " .. value)
                elseif key == "key" then
                    -- Handle key format
                    if value:match('^".*"$') then
                        -- String key like "E"
                        local keyName = value:match('^"(.*)"$')
                        table.insert(output, "SkyX.Aimbot.TriggerKey = Enum.KeyCode." .. keyName)
                    else
                        -- Direct Enum
                        table.insert(output, "SkyX.Aimbot.TriggerKey = " .. value)
                    end
                end
            end
        end
    end
    
    -- Add aimbot implementation
    local aimbotImpl = [[
-- Initialize Aimbot when SkyX starts
SkyX.initFunctions = SkyX.initFunctions or {}
table.insert(SkyX.initFunctions, function()
    -- Only initialize once
    if SkyX._aimbotInitialized then return end
    SkyX._aimbotInitialized = true
    
    -- Check for Drawing library
    if not Drawing then
        SkyX:warn("Drawing library not available, Aimbot FOV will not be visible")
    else
        -- Create FOV circle
        SkyX.Aimbot.FOVCircle = Drawing.new("Circle")
        SkyX.Aimbot.FOVCircle.Thickness = 1
        SkyX.Aimbot.FOVCircle.NumSides = 36
        SkyX.Aimbot.FOVCircle.Radius = SkyX.Aimbot.FOV
        SkyX.Aimbot.FOVCircle.Filled = false
        SkyX.Aimbot.FOVCircle.Visible = false
        SkyX.Aimbot.FOVCircle.Color = SkyX.Aimbot.FOVColor
    end
    
    -- Variables
    SkyX.Aimbot.Aiming = false
    SkyX.Aimbot.Target = nil
    
    -- Function to check if target is valid
    function SkyX.Aimbot:IsValidTarget(player)
        if player == game.Players.LocalPlayer then return false end
        
        -- Team check
        if self.TeamCheck and player.Team == game.Players.LocalPlayer.Team then 
            return false 
        end
        
        -- Character and humanoid check
        local character = player.Character
        if not character then return false end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then return false end
        
        -- Target part check
        if not character:FindFirstChild(self.TargetPart) then return false end
        
        return true
    end
    
    -- Function to get the closest player to the mouse
    function SkyX.Aimbot:GetClosestPlayerToMouse()
        local closestPlayer = nil
        local closestDistance = self.FOV
        
        local mouse = game.Players.LocalPlayer:GetMouse()
        local camera = workspace.CurrentCamera
        
        for _, player in pairs(game.Players:GetPlayers()) do
            if self:IsValidTarget(player) then
                local targetPart = player.Character[self.TargetPart]
                local screenPoint, onScreen = camera:WorldToViewportPoint(targetPart.Position)
                
                if onScreen then
                    local screenDistance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
                    
                    if screenDistance < closestDistance then
                        closestPlayer = player
                        closestDistance = screenDistance
                    end
                end
            end
        end
        
        return closestPlayer
    end
    
    -- Function to update FOV circle
    function SkyX.Aimbot:UpdateFOVCircle()
        if not Drawing or not self.FOVCircle then return end
        
        if self.ShowFOV and self.Enabled then
            self.FOVCircle.Position = Vector2.new(game.Players.LocalPlayer:GetMouse().X, game.Players.LocalPlayer:GetMouse().Y + 36)
            self.FOVCircle.Radius = self.FOV
            self.FOVCircle.Visible = true
            self.FOVCircle.Color = self.FOVColor
        else
            self.FOVCircle.Visible = false
        end
    end
    
    -- Function to aim at target
    function SkyX.Aimbot:AimAtTarget()
        if not self.Target or not self.Enabled or not self.Aiming then return end
        
        local camera = workspace.CurrentCamera
        local targetPart = self.Target.Character[self.TargetPart]
        
        -- Apply smoothing
        local targetCFrame = CFrame.new(camera.CFrame.Position, targetPart.Position)
        camera.CFrame = camera.CFrame:Lerp(targetCFrame, 1 - self.Smoothness)
    end
    
    -- Key connections
    game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == SkyX.Aimbot.TriggerKey then
            SkyX.Aimbot.Aiming = true
        end
    end)
    
    game:GetService("UserInputService").InputEnded:Connect(function(input, gameProcessed)
        if input.KeyCode == SkyX.Aimbot.TriggerKey then
            SkyX.Aimbot.Aiming = false
        end
    end)
    
    -- Main aimbot loop
    game:GetService("RunService").RenderStepped:Connect(function()
        SkyX.Aimbot:UpdateFOVCircle()
        
        if SkyX.Aimbot.Enabled then
            SkyX.Aimbot.Target = SkyX.Aimbot:GetClosestPlayerToMouse()
            SkyX.Aimbot:AimAtTarget()
        end
    end)
    
    SkyX:log("Aimbot system initialized")
end)
]]
    
    table.insert(output, aimbotImpl)
    
    return table.concat(output, "\n")
end

-- Create the compiler
local compiler = SkyXCompiler.new()

-- Return the compiler or use it directly
return function(code)
    if code then
        return compiler:compile(code)
    else
        return compiler
    end
end
